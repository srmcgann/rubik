<!DOCTYPE html>
<html>
  <head>
    <title>Coordinates boilerplate example</title>
    <style>
      html, body{
        background-repeat: no-repeat;
        background-position: center center;
        background-image: background-size: 100% 100%;
        background-color: #000;
        margin: 0;
        min-height: 100vh;
        overflow: hidden;
      }
      .loadingText{
        position: absolute;
        color: #888;
        font-family: monospace;
        font-size: 64px;
        width: 400px;
        display: block;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      .overlay{
        position: fixed;
        left: 0;
        top: 0;
        width: 100vw;
        height: 100vh;
        background: #111e;
        z-index: 100;
        display: none;
      }
      #guideFrame{
        margin-top: 20px;
        width: 100vw;
        height: calc(100vh - 20px);
        border: none;
      }
      .closeButton{
        position: absolute;
        z-index: 100;
        top: 1px;
        right: 10px;
        background: #400;
        color: #c22;
        border: 1px solid #800;
        border-radius: 10px;
        width: 150px;
        font-size: 14px;
        font-family: verdana;
        cursor: pointer;
        line-height: 1em;
        padding-5px;
        font-weight: 900;
      }
      #guideTitle{
        position: absolute;
        z-index: 100;
        top: 1px;
        left: 10px;
        font-size: 14px;
        font-family: verdana;
        color: #0f4;
      }
    </style>
  </head>
  <body>
    <div class="overlay">
      <span id="guideTitle">The official Rubik's Cube Guide</span>
      <button
        class="closeButton"
        onclick="window.HideOverlay()"
      >close</button>
      <iframe id="guideFrame"></iframe>
    </div>
    <div class="loadingText" id="loadingTextDiv">loading....</div>
    <script type="module">

      window.addEventListener('load', () => { window.loaded = true } ) 
      window.loaded = false
      var loop = () => {
        var el = document.querySelector('#loadingTextDiv')
        el.innerHTML = 'loading' + ('.').repeat(((new Date()).getTime()/100*6)%8)
        if(!window.loaded) {
          requestAnimationFrame(loop)
        } else {
          document.querySelector('#loadingTextDiv').remove()
        }
      }
      loop()

      import * as Coordinates from
      "https://srmcgann.github.io/Coordinates/coordinates.min.js"
      //"https://textfile.root.sx/coordinates.js"


      var rendererOptions = {
        ambientLight: .5, margin: 0,
        fov: 1200, width: 1920, height: 1080,
        //fov: 1e3/2, width: 1920/2, height: 1080/2,
        // uncomment above for lower-res, higher-performance canvas
      }
      var renderer = await Coordinates.Renderer(rendererOptions)

      var refTexture = 'https://srmcgann.github.io/Coordinates/resources/bumpmap_equirectangular_po2.jpg'

      var S = Math.sin
      var C = Math.cos
      var Rn = Math.random

      var x, y, z, p, q, d

      Coordinates.AnimationLoop(renderer, 'Draw')

      var c = Coordinates.Overlay.c
      var ctx = Coordinates.Overlay.ctx

      var overlay = new Image()
      var overlayURL = 'https://srmcgann.github.io/objs/rubik/overlay.png'
      fetch(overlayURL).then(res=>res.blob()).then(data => {
        overlay.src = URL.createObjectURL(data)
      })

      var shaderOptions = [
        {lighting: {type: 'ambientLight', value: 1}},
        { uniform: {
          type: 'phong',
          flatShading: true,
          value: .1
        } },
        { uniform: {
          type: 'reflection',
          map: refTexture,
          enabled: false,
          value: .1
        } },
        { uniform: {
          type: 'refraction',
          map: refTexture,
          enabled: false,
          angleOfRefraction: .4,
          value: .3
        } },
      ]
      var shader = await Coordinates.BasicShader(renderer, shaderOptions)

      var shaderOptions = [
        {lighting: {type: 'ambientLight', value: .25}},
        { uniform: {
          type: 'phong',
          flatShading: true,
          value: .05
        } },
        { uniform: {
          type: 'reflection',
          map: refTexture,
          enabled: false,
          value: .1
        } },
        { uniform: {
          type: 'refraction',
          map: refTexture,
          enabled: false,
          angleOfRefraction: .4,
          value: .3
        } },
      ]
      var cursorShader = await Coordinates.BasicShader(renderer, shaderOptions)

      var shaderOptions = [
        {lighting: {type: 'ambientLight', value: .2}},
        { uniform: {
          type: 'phong',
          value: 0
        } }
      ]
      var backgroundShader = await Coordinates.BasicShader(renderer, shaderOptions)

      var shapes = []

      var geoOptions = {
        shapeType: 'dodecahedron',
        name: 'background',
        sphereize: 1,
        subs: 4,
        map: refTexture,
        size: 5e3,
        colorMix: 0,
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        shapes.push(geometry)
        await backgroundShader.ConnectGeometry(geometry)
      })  

      var sp = 3 * (2**.5)/2.166

      var pointArray = []
      Array(9*3).fill().map((v, i) => {
        if(i!=13){
          x = ((i%3)-3/2+.5) * sp
          y = (((i/3|0)%3)-3/2+.5) * sp
          z = ((i/9|0)-3/2+.5) * sp
          pointArray.push([x, y, z])
        }
      })

      var rubikShape
      var baseRubikShape = {
        vertices: [],
        uvs: [],
        normals: [],
        normalVecs: [],
        normalAssocs: [],
        ustate: [],
        vstate: [],
        nstate: [],
        nvstate: [],
        shapeData: []
      }
      var geoOptions = {
        shapeType: 'obj',
        url: 'https://srmcgann.github.io/objs/rubik/rubik.obj',
        map: 'https://srmcgann.github.io/objs/rubik/rubik.png',
        name: 'rubiks cube',
        colorMix: 0,
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        Coordinates.ShapeFromArray(geometry, pointArray).then(async res => {
          Object.keys(baseRubikShape).forEach(key => {
             baseRubikShape[key] = structuredClone(res[key])
          })
          rubikShape = res
          shapes.push(res)
          await shader.ConnectGeometry(res)
        })
      })  

      var cursorShape, baseCursorShape
      var geoOptions = {
        shapeType: 'obj',
        url: 'https://srmcgann.github.io/objs/rubik/face_cursor.obj',
        name: 'cursor',
        disableDepthTest: true,
        scaleZ: -1,
        cullFace: 'front',
        alpha: .9,
        colorMix: .8,
      }
      await Coordinates.LoadGeometry(renderer, geoOptions).then(async (geometry) => {
        baseCursorShape = structuredClone(geometry.vertices)
        cursorShape = geometry
        shapes.push(geometry)
        await cursorShader.ConnectGeometry(geometry)
      })  

      var shuffleTTL = 0
      const Shuffle = (override = false) => {
        if(override || confirm('\n\nShuffle?\n\nare you sure?')){
          setTimeout(()=>{
            if(shuffleTTL < renderer.t && !solving) {
              shuffleTTL = renderer.t + 3
              ChooseMove()
            }
          })
        }
      }

      if(0) Coordinates.LoadFPSControls(renderer, {
        flyMode: true,
        mSpeed: 1,
        crossharSel: 2,
        crosshairSize: .5,
      })

      //uncomment above to enable mouse/keyboard controls

      var solving, solvingStage
      const SolveCube = (override = false) => {
        if(shuffleTTL > renderer.t) return
        if(override || confirm('\n\nSolve cube?\n\nare you sure?')){
          console.log('solving cube')
          solving = true
          solveSet = basesolveSet = {
            solvingStage: 0,
            stageProgress: 0,
            workingFace: '',
            tgts: [],
            tgtColors: [],
            queue: [],
            memo: [],
            faces: []
          }
        }
      }

      var comp0, comp1, comp2, comp3, comp4, comp5, comp6
      var a, b, theta, phase

      var defaultSpeed = .5, speed
      const Shift = ( face, dir=1, trial=false, ids = [], turns=1 ) => {
        var t_rubikShape
        var t_identities
        if(trial){
          speed = 1
          t_rubikShape = 
          {
            vertices: structuredClone(rubikShape.vertices),
            vstate: structuredClone(rubikShape.vstate),
            shapeData: structuredClone(rubikShape.shapeData),
          }
          t_identities = structuredClone(ids)
        }else{
          speed = defaultSpeed
          t_rubikShape = rubikShape
          t_identities = identities
        }
        
        var set, spd
        phase = Math.min(1, phase)
        
        if(phase <= 1-speed){
          spd = Math.min(speed, 1-phase)
        }else{
          return false
        }
          switch(face){
            case 'front':
              set = [
                [-1, -1,  -1],
                [0,  -1,  -1],
                [1,  -1,  -1],
                [-1,  0,  -1],
                [0,   0,  -1],
                [1,   0,  -1],
                [-1,  1,  -1],
                [0,   1,  -1],
                [1,   1,  -1],
              ]
              comp0 = 'roll'
              comp1 = 'x'
              comp2 = 'y'
              comp3 = 'ox'
              comp4 = 'oy'
              comp5 = 'wx'
              comp6 = 'wy'
              break
            case 'left':
              set = [
                [-1,  -1, -1],
                [-1,  0,  -1],
                [-1,  1,  -1],
                [-1,  -1,  0],
                [-1,  0,   0],
                [-1,  1,   0],
                [-1,  -1,  1],
                [-1,  0,   1],
                [-1,  1,   1],
              ]
              comp0 = 'pitch'
              comp1 = 'y'
              comp2 = 'z'
              comp3 = 'oy'
              comp4 = 'oz'
              comp5 = 'wy'
              comp6 = 'wz'
              break
            case 'right':
              set = [
                [1,  -1, -1],
                [1,  0,  -1],
                [1,  1,  -1],
                [1,  -1,  0],
                [1,  0,   0],
                [1,  1,   0],
                [1,  -1,  1],
                [1,  0,   1],
                [1,  1,   1],
              ]
              dir *= -1
              comp0 = 'pitch'
              comp1 = 'y'
              comp2 = 'z'
              comp3 = 'oy'
              comp4 = 'oz'
              comp5 = 'wy'
              comp6 = 'wz'
              break
            case 'back':
              set = [
                [-1, -1,  1],
                [0,  -1,  1],
                [1,  -1,  1],
                [-1,  0,  1],
                [0,   0,  1],
                [1,   0,  1],
                [-1,  1,  1],
                [0,   1,  1],
                [1,   1,  1],
              ]
              dir *= -1
              comp0 = 'roll'
              comp1 = 'x'
              comp2 = 'y'
              comp3 = 'ox'
              comp4 = 'oy'
              comp5 = 'wx'
              comp6 = 'wy'
              break
            case 'bottom':
              set = [
                [-1, -1, -1],
                [0,  -1, -1],
                [1,  -1, -1],
                [-1, -1,  0],
                [0,  -1,  0],
                [1,  -1,  0],
                [-1, -1,  1],
                [0,  -1,  1],
                [1,  -1,  1],
              ]
              comp0 = 'yaw'
              comp1 = 'x'
              comp2 = 'z'
              comp3 = 'ox'
              comp4 = 'oz'
              comp5 = 'wx'
              comp6 = 'wz'
              break
            case 'top':
              set = [
                [-1, 1, -1],
                [0,  1, -1],
                [1,  1, -1],
                [-1, 1,  0],
                [0,  1,  0],
                [1,  1,  0],
                [-1, 1,  1],
                [0,  1,  1],
                [1,  1,  1],
              ]
              dir *= -1
              comp0 = 'yaw'
              comp1 = 'x'
              comp2 = 'z'
              comp3 = 'ox'
              comp4 = 'oz'
              comp5 = 'wx'
              comp6 = 'wz'
              break
          }
          theta = Math.PI/2 * dir * spd * turns
          t_rubikShape.shapeData.map((subShape, sidx) => {
            x = subShape.wx
            y = subShape.wy
            z = subShape.wz
            px = Math.round(x/sp)
            py = Math.round(y/sp)
            pz = Math.round(z/sp)
            set.forEach(v=>{
              if(px == v[0] && py == v[1] && pz == v[2]){
                subShape[comp0] += theta
                a = subShape[comp5]
                b = subShape[comp6]
                p = Math.atan2(a, b) + theta
                d = Math.hypot(a, b)
                subShape[comp1] = S(p) * d - subShape[comp3]
                subShape[comp2] = C(p) * d - subShape[comp4]
              }
            })
          })
          idc.map((face, iIdx) => {
            face.map((id, fidx) => {
              px = Math.round(id.x/sp)
              py = Math.round(id.y/sp)
              pz = Math.round(id.z/sp)
              set.forEach(v=>{
                if(Math.hypot(px-v[0],py-v[1],pz-v[2])==1){
                  px = v[0]
                  py = v[1]
                  pz = v[2]
                }
                if(px == v[0] && py == v[1] && pz == v[2]){
                  a = id[comp1]
                  b = id[comp2]
                  p = Math.atan2(a, b) + Math.PI/2 * dir * (phase+speed) * turns
                  d = Math.hypot(a, b)
                  t_identities[iIdx][fidx][comp1] = S(p) * d
                  t_identities[iIdx][fidx][comp2] = C(p) * d
                }
              })
            })
          })

        phase += speed
        return trial ? { rubikShape: t_rubikShape,
                         identities: t_identities } : true
      }


      var px, py, pz, curMove = '', tryMove = ''

      var faces = [
        'front',
        'left',
        'right',
        'top',
        'bottom',
        'back',
      ]

      const ChooseMove = () => {
        if(shuffleTTL > renderer.t){
          Coordinates.ApplyShapeData(rubikShape)
          curMove = [
            faces[faces.length*Rn()|0],
            Rn() < .5 ? 1 : -1
          ]
          phase = 0
        }
      }

      const RotateFace = dir => {
        if(shuffleTTL < renderer.t &&
           (solving || !numlock) && (phase == 0 || phase == 1)){
          Coordinates.ApplyShapeData(rubikShape)
          curMove = [ curCursorView,
                     curCursorView == 'top' ||
                     curCursorView == 'bottom' ? -dir : dir]
          phase = 0
        }
      }

      const TryRotateFace = (face, dir, ids, turns = 1) => {
        if(shuffleTTL < renderer.t &&
           (solving || !numlock) && (phase == 0 || phase == 1)){
          Coordinates.ApplyShapeData(rubikShape)
          var TryMove = [ face, face == 'top' || face == 'bottom' ? -dir : dir]
          phase = 0
          
          var res = Shift(...TryMove, true, ids, turns)
          
          for(var i = 0; i < res.identities.length; i++){
            for(var k = 0; k < res.identities[i].length; k++){
              var mind = 6e6, tidx1
              var tx = res.identities[i][k].x
              var ty = res.identities[i][k].y
              var tz = res.identities[i][k].z
              for(var j = 0; j < res.identities.length; j++){
                x = res.identities[j][4].x
                y = res.identities[j][4].y
                z = res.identities[j][4].z
                if((d = Math.hypot(x-tx, y-ty, z-tz)) < mind){
                  mind = d
                  tidx1 = j
                }
              }
              res.identities[i][k].posId = tidx1
            }
          }
          return GeneratesolveSet(res.identities)
        }
      }
      
      const Adjoining = (el, ids) => {
        var ret = []
        var x1 = Math.round(el.x / sp / 1.2)
        var y1 = Math.round(el.y / sp / 1.2)
        var z1 = Math.round(el.z / sp / 1.2)
        ids.forEach((face, fidx) => {
          face.forEach((el2, idx2) => {
            var x2 = Math.round(el2.x / sp / 1.2)
            var y2 = Math.round(el2.y / sp / 1.2)
            var z2 = Math.round(el2.z / sp / 1.2)
            if(x1 == x2 &&
               y1 == y2 &&
               z1 == z2 &&
               (el2.id != el.id ||
               el2.posId != el.posId)) ret.push({
                 fidx, idx2,
                 adjoining: structuredClone(el2)
               })
          })
        })
        return ret
      }

      const RelativeFace = (cur, tgt) => {
        switch(cur){
          case 'back':
            switch(tgt){
              case 'back': return 'front'; break
              case 'top': return 'top'; break
              case 'right': return 'left'; break
              case 'front': return cur; break
              case 'bottom': return 'bottom'; break
              case 'left': return 'right'; break
            }
          break
          case 'top':
            switch(tgt){
              case 'back': return 'bottom'; break
              case 'top': return 'back'; break
              case 'right': return 'right'; break
              case 'front': return cur; break
              case 'bottom': return 'front'; break
              case 'left': return 'left'; break
            }
          break
          case 'right':
            switch(tgt){
              case 'back': return 'left'; break
              case 'top': return 'top'; break
              case 'right': return 'back';break
              case 'front': return cur; break
              case 'bottom': return 'bottom'; break
              case 'left': return 'front'; break
            }
          break
          case 'front':
            switch(tgt){
              case 'back': return 'back'; break
              case 'top': return 'top'; break
              case 'right': return 'right'; break
              case 'front': return cur; break
              case 'bottom': return 'bottom'; break
              case 'left': return 'left'; break
            }
          break
          case 'bottom':
            switch(tgt){
              case 'back': return 'top'; break
              case 'top': return 'front'; break
              case 'right': return 'right'; break
              case 'front': return cur; break
              case 'bottom': return 'back'; break
              case 'left': return 'left'; break
            }
          break
          case 'left':
            switch(tgt){
              case 'back': return 'right'; break
              case 'top': return 'top'; break
              case 'right': return 'front'; break
              case 'front': return cur; break
              case 'bottom': return 'bottom'; break
              case 'left': return 'back'; break
            }
          break
        }
      }
      

      const FaceToBottom = () => {
        if(numlock) return
        Coordinates.ApplyShapeData(rubikShape)
        const DoRotation = (theta, axis) => {
          a = axis == 'roll' ? 'x' : 'y'
          b = axis == 'roll' ? 'y' : 'z'
          rubikShape.shapeData.map((subShape, sidx) => {
            x = subShape.wx
            y = subShape.wy
            z = subShape.wz
            subShape[axis] += theta
            var a_ = subShape['w'+a]
            var b_ = subShape['w'+b]
            p = Math.atan2(a_, b_) + theta
            d = Math.hypot(a_, b_)
            subShape[a] = S(p) * d - subShape['o'+a]
            subShape[b] = C(p) * d - subShape['o'+b]
          })
          
          faceAssocs.map((assoc, aidx) => {
            var a = axis == 'roll' ? 'x' : 'y'
            var b = axis == 'roll' ? 'y' : 'z'
            var a_ = assoc.pos[a]
            var b_ = assoc.pos[b]
            p = Math.atan2(a_, b_) - theta
            d = Math.hypot(a_, b_)
            faceAssocs[aidx].pos[a] = Math.round(S(p) * d)
            faceAssocs[aidx].pos[b] = Math.round(C(p) * d)
          })
          
          identities.map((face, fidx) => {
            face.map((id, iIdx) => {
              var a_ = id[a]
              var b_ = id[b]
              p = Math.atan2(a_, b_) + theta
              d = Math.hypot(a_, b_)
              id[a] = S(p) * d
              id[b] = C(p) * d
            })
          })
        }
        var a, b, theta
        switch(curCursorView){
          case 'bottom': break
          case 'left':
            DoRotation(-Math.PI/2, 'roll')
            break
          case 'front':
            DoRotation(Math.PI/2, 'pitch')
            break
          case 'right':
            DoRotation(Math.PI/2, 'roll')
            break
          case 'back':
            DoRotation(-Math.PI/2, 'pitch')
            break
          case 'top':
            DoRotation(Math.PI, 'pitch')
            break
        }
        curCursorView = 'bottom'
        
      }

      var c = Coordinates.Overlay.c
      var ctx = Coordinates.Overlay.ctx

      var keys, keyTimers
      var keyTimerInterval = .05

      const ResetViews = () => {
        numlock = true
        buttons.filter(v=>v.name == 'oscillation')[0].clickState = false
        doOscillate = false
        curView = 'front'
        if(numlock){
          orbitYaw = 0
          orbitPitch = 0
        }
      }

      const DoKeys = () => {
        peekView = ''
        keys.map((state, key) => {
          if(state && keyTimers[key] < renderer.t){
            switch(key){
              case 13:  // enter
                enterKeyHasBeenPressed = true
                ResetViews()
                // Init(true)
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 79:  // o
                var cs = buttons.filter(v=>v.name == 'oscillation')[0].clickState
                buttons.filter(v=>v.name == 'oscillation')[0].clickState = !cs
                doOscillate = !cs
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 66:  // b
                FaceToBottom()
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 82:  // r
                Shuffle()
                keys[key] = false
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 87:  // w
                peekView = 'top'
                break
              case 77:  // m
                numlock = !numlock
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 65:  // a
                peekView = 'left'
                break
              case 83:  // s
                peekView = 'bottom'
                break
              case 68:  // d
                peekView = 'right'
                break
              case 88:  // x
                peekView = 'back'
                break
              case 109:
                RotateFace(-1)
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 107:
                RotateFace(1)
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 32:
                break
              case 71:
                if(shuffleTTL < renderer.t) {
                  SolveCube()
                  keyTimers[key] = renderer.t + keyTimerInterval
                }
                break
              case 100:
                enterKeyHasBeenPressed = true
                curView = 'left'
                keyTimers[key] = renderer.t + keyTimerInterval
                if(numlock){
                  orbitYaw = 0
                  orbitPitch = 0
                }
                break
              case 96:
                enterKeyHasBeenPressed = true
                curView = 'front'
                keyTimers[key] = renderer.t + keyTimerInterval
                if(numlock){
                  orbitYaw = 0
                  orbitPitch = 0
                }
                break
              case 102:
                enterKeyHasBeenPressed = true
                curView = 'right'
                keyTimers[key] = renderer.t + keyTimerInterval
                if(numlock){
                  orbitYaw = 0
                  orbitPitch = 0
                }
                break
              case 104:
                enterKeyHasBeenPressed = true
                curView = 'top'
                keyTimers[key] = renderer.t + keyTimerInterval
                if(numlock){
                  orbitYaw = 0
                  orbitPitch = 0
                }
                break
              case 98:
                enterKeyHasBeenPressed = true
                curView = 'bottom'
                keyTimers[key] = renderer.t + keyTimerInterval
                if(numlock){
                  orbitYaw = 0
                  orbitPitch = 0
                }
                break
              case 101:
                enterKeyHasBeenPressed = true
                curView = 'back'
                keyTimers[key] = renderer.t + keyTimerInterval
                if(numlock){
                  orbitYaw = 0
                  orbitPitch = 0
                }
                break
              case 188:
                RotateFace(-1)
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 190:
                RotateFace(1)
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 37:
                numlock = false
                curCursorView = 'left'
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 45:
                numlock = false
                curCursorView = 'front'
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 39:
                numlock = false
                curCursorView = 'right'
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 38:
                numlock = false
                curCursorView = 'top'
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 40:
                numlock = false
                curCursorView = 'bottom'
                keyTimers[key] = renderer.t + keyTimerInterval
                break
              case 12:
                numlock = false
                curCursorView = 'back'
                keyTimers[key] = renderer.t + keyTimerInterval
                break
            }
          }
        })
      }
      
      const FaceIsVisible = face => {
        x = faceAssocs[face].pos.x
        y = -faceAssocs[face].pos.y
        z = faceAssocs[face].pos.z
        
        p = Math.atan2(x, z) + rubikShape.yaw
        d = Math.hypot(x, z)
        z = C(p) * d
        p = Math.atan2(y, z) + rubikShape.pitch
        d = Math.hypot(y, z)
        z = C(p) * d
        
        return z < -.2
      }

      c.tabIndex = 0
      var mx = 0
      var my = 0
      var mb = false

      window.onmouseup = e => {
        if(e.which == 1) {
          mb = 0
          clicked = false
        }
        c.focus()
      }

      Coordinates.Overlay.c.oncontextmenu = e => {
        e.stopPropagation()
        e.preventDefault()
      }

      
      window.onmousedown = e => {

        mouseButtonHasBeenClicked = true
        if(e.which == 1 && !highlighted){
          mx = renderer.mouseX
          my = renderer.mouseY
          mb = true
        }
        if(e.which == 1) clickedWhileHighlighted = highlighted
        c.focus()
      }
      window.onmousemove = e => {
        if(mb){
          var deltax = renderer.mouseX - mx
          var deltay = renderer.mouseY - my
          orbitYaw -= deltax / 100
          orbitPitch += deltay / 100
        }
        mx = renderer.mouseX
        my = renderer.mouseY
      }

      const ViewSide = faceName => {
        curView = faceName
        if(numlock){
          orbitYaw = 0
          orbitPitch = 0
        }
      }

      c.focus()
      c.onkeydown = e => {
        keyHasBeenPressed = true
        console.log(e.keyCode)
        //numlock = e.getModifierState('NumLock')
        keys[e.keyCode] = true
      }
      c.onkeyup = e => {
        keys[e.keyCode] = false
        keyTimers[e.keyCode] = 0
      }


      var ctLookup = [
        [ 4, 4, 2, 5, 0, 2, 5, 1, 1 ],
        [ 3, 5, 5, 3, 0, 0, 2, 2, 0 ],
        [ 4, 3, 3, 4, 0, 1, 0, 0, 1 ],
        [ 2, 1, 1, 2, 0, 5, 4, 4, 5 ],
        [ 2, 2, 3, 0, 0, 3, 0, 5, 5 ],
        [ 1, 0, 0, 1, 0, 4, 3, 3, 4 ],
      ]


      var curView, curCursorView
      var camPitch, camYaw, cursorYaw, cursorPitch, tracking = .1
      var keyHasBeenPressed, numlock, peekView, doOscillate
      var orbitYaw, orbitPitch, mouseButtonHasBeenClicked
      var enterKeyHasBeenPressed, highlighted, clicked, idc
      var oph, clickedWhileHighlighted, faceAssocs, showColorNames = false
      var clickTargets, identities, solveSet, basesolveSet

      const Init = (reset = false) => {

        if(!reset){
          //Shuffle()
          ChooseMove()
          clicked = false
          solving = false
          keys = Array(256).fill(false)
          keyTimers = Array(256).fill(0)
          keyTimerInterval = .5
          keyHasBeenPressed = false
          mouseButtonHasBeenClicked = false
          enterKeyHasBeenPressed = false
          curCursorView = 'front'
          phase = 1
          highlighted = false
          clickedWhileHighlighted = false
        }

        showColorNames = false
        numlock = true
        orbitYaw = 0
        orbitPitch = 0
        doOscillate = false
        peekView = ''
        camPitch = 0
        camYaw = 0
        cursorPitch = 0
        cursorYaw = 0
        curView = 'front'


        faceAssocs = [
          {
            color: 'yellow',
            opos: {x:0, y:0, z:1},
            pos: {x:0, y:0, z:1},
            oid: 0
          },
          {
            color: 'red',
            opos: {x:0, y: -1, z: 0},
            pos: {x:0, y: -1, z: 0},
            oid: 1
          },
          {
            color: 'blue',
            opos: {x:1, y: 0, z: 0},
            pos: {x:1, y: 0, z: 0},
            oid: 2},
          {
            color: 'white',
            opos: {x:0, y: 0, z: -1},
            pos: {x:0, y: 0, z: -1},
            oid: 3},
          {
            color: 'orange',
            opos: {x:0, y: 1, z: 0},
            pos: {x:0, y: 1, z: 0},
            oid: 4},
          {
            color: 'green',
            opos: {x:-1, y: 0, z: 0},
            pos: {x:-1, y: 0, z: 0},
            oid: 5},
        ]

        clickTargets = []
        identities = Array(6).fill().map((v, i)=>Array(9).fill(0))
        for(var i = 0; i < 6; i++){
          var a = [], b=[], l, ls = 4.2
          for(var j = 0; j < 4; j++){
            a = [S(p=Math.PI*2/4*j+Math.PI/4)*ls/1.5, C(p)*ls/1.5, ls*2**.5/2]
            b.push([a[(i+0)%3]*(l=i<3?1:-1), a[(i+1)%3]*l, a[(i+2)%3]*l])
          }
          clickTargets.push([b, i, 1])
          for(var k = 0; k < 9; k++){
            var tx = ((k%3)-3/2+.5) * ls/2.1
            var ty = ((k/3|0)-3/2+.5) * ls/2.1
            
            a = [tx, ty, ls*2**.5/2]
            identities[i][k] = {
              x: a[(i+0)%3]*(l=i<3?1:-1),
              y: a[(i+1)%3]*l,
              z: a[(i+2)%3]*l,
              id: i,
              posId: i,
            }
            
            if(k!=4){
              b = []
              for(var j = 0; j < 4; j++){
                a = [S(p=Math.PI*2/4*j+Math.PI/4)*ls/2.95+tx, C(p)*ls/2.95+ty, ls*2**.5/2]
                b.push([a[(i+0)%3]*(l=i<3?1:-1), a[(i+1)%3]*l, a[(i+2)%3]*l])
              }
              clickTargets.push([b, ctLookup[i][k], 0])
            }
          }
        }

      }
      Init()
      
      const ResetCube = (override = false) => {
        if(override || confirm('\n\nreset whole cube?\n\nAre you sure?')) {
          Coordinates.ApplyShapeData(rubikShape)
          rubikShape.shapeData = structuredClone(baseRubikShape.shapeData)
          Object.keys(baseRubikShape).forEach(key => {
             rubikShape[key] = structuredClone(baseRubikShape[key])
          })
          Init()
          setTimeout(()=>{
            Coordinates.ApplyShapeData(rubikShape)
          }, 0)
        }
      }
      
      const tgtOriFromFace = face => {
        return tgtOris.filter(v=>v.name==face)[0].oid
      }
      
      var tgtOris = [
        {
          oid: 0,
          name: 'back',
          position: [0, 0, 1],
          yaw: Math.PI, pitch: 0,
          cursorYaw: Math.PI, cursorPitch: 0,
        },
        {
          oid: 1,
          name: 'top',
          position: [0, -1, 0],
          yaw: 0, pitch: -Math.PI/2,
          cursorYaw: 0, cursorPitch: -Math.PI/2,
        },
        {
          oid: 2,
          name: 'right',
          position: [1, 0, 0],
         yaw: Math.PI/2, pitch: 0,
         cursorYaw: Math.PI/2, cursorPitch: 0,
        },
        {
          oid: 3,
          name: 'front',
          position: [0, 0, -1],
          yaw: 0, pitch: 0,
          cursorYaw: 0, cursorPitch: 0
        },
        {
          oid: 4,
          name: 'bottom',
          position: [0, 1, 0],
          yaw: 0, pitch: Math.PI/2,
          cursorYaw: 0, cursorPitch: Math.PI/2,
        },
        {
          oid: 5,
          name: 'left',
          position: [-1, 0, 0],
          yaw: -Math.PI/2, pitch: 0,
          cursorYaw: -Math.PI/2, cursorPitch: 0,
        },
      ]

      const IdFaceLookup = idx => {
        return faceAssocs[idx].color
      }

      const FaceColorLookup = face => {
        return faceAssocs[tgtOris.filter(v=>v.name==face)[0].oid].color
      }

      var offsetz = 0
      var oscx, oscy
      var defaultOscx = -Math.PI/4 + Math.PI
      var defaultOscy = Math.PI/5

      var buttons = [
        {
          name: 'View Rubiks Guide',
          style: 'toggle',
          text: 'vew Rubiks Guide [g]',
          clickState: false,
          fontColor: '#021',
          buttonColor: '#282',
          highlightColor: '#4f4',
          script: 'ShowGuide()',
          enabled: true,
        },
        {
          name: 'oscillation',
          style: 'toggle',
          text: 'oscillate [o]',
          clickState: false,
          fontColor: '#fff',
          buttonColor: '#028',
          highlightColor: '#804',
          script: 'doOscillate = !doOscillate',
          enabled: true,
        },
        {
          name: 'set cube bottom',
          style: 'one click',
          text: 'face -> bottom [b]',
          clickState: false,
          fontColor: '#fff',
          buttonColor: '#028',
          highlightColor: '#804',
          script: 'FaceToBottom()',
          enabled: true,
        },
        {
          name: 'shuffle',
          style: 'one click',
          text: 'shuffle / randomize [r]',
          clickState: false,
          fontColor: '#fff',
          buttonColor: '#028',
          highlightColor: '#804',
          script: 'Shuffle()',
          enabled: true,
        },
        {
          name: 'reset views',
          style: 'one click',
          text: 'reset views [ENTER]',
          clickState: false,
          fontColor: '#fff',
          buttonColor: '#028',
          highlightColor: '#804',
          script: 'ResetViews()',
          enabled: true,
        },
        {
          name: 'reset whole cube',
          style: 'one click',
          text: 'reset whole cube',
          clickState: false,
          fontColor: '#f44',
          buttonColor: '#400',
          highlightColor: '#800',
          script: 'ResetCube()',
          enabled: true,
        },
        {
          name: 'solve cube',
          style: 'one click',
          text: 'solve cube',
          clickState: false,
          fontColor: '#fff',
          buttonColor: '#804',
          highlightColor: '#f08',
          script: 'SolveCube()',
          enabled: true,
        },
        /*
        {
          name: 'disabled button',
          style: 'one click',
          text: 'disabled button',
          clickState: false,
          fontColor: '#888',
          buttonColor: '#333',
          highlightColor: '#333',
          script: '',
          enabled: false,
        },*/
      ]
      
      const GeneratesolveSet = resource => {
        var ret = structuredClone(basesolveSet)
        ret.workingFace = ''
        ret.faces = Array(6).fill().map(v=>{
          return {
            face: '',
            set: Array(9).fill(-1),
          }
        })
        resource.forEach((face, fidx) => {
          face.forEach(id => {
            x = Math.round(id.x/sp/1.2)
            y = Math.round(id.y/sp/1.2)
            z = Math.round(id.z/sp/1.2)
            if(fidx == face[4].posId){
              var colorName = IdFaceLookup(id.id)
              var faceName = tgtOris[id.posId].name
              var idx, fx, fy
              switch(faceName){
                case 'back':
                  idx = 8-((x+1)%3 + (y+1)*3)
                  fx = -x, fy = -y
                break
                case 'top':
                  idx = (x+1)%3 + (2-(z+1))*3
                  fx = x, fy = -z
                break
                case 'right':
                  idx = (z+1)%3 + (2-(y+1))*3
                  fx = z, fy = -y
                break
                case 'front':
                  idx = (x+1)%3 + (2-(y+1))*3
                  fx = x, fy = -y
                break
                case 'bottom':
                  idx = (x+1)%3 + (z+1)*3
                  fx = x, fy = z
                break
                case 'left':
                  idx = 8 - ((z+1)%3 + (y+1)*3)
                  fx = -z, fy = -y
                  break
              }
              
              
              ret.faces[id.posId].face = faceName
              ret.faces[id.posId].set[idx] = {
                posId: id.posId,
                colorName,
                x, y, z, fx, fy,
                id: id.id,
                rx: id.x,
                ry: id.y,
                rz: id.z,
                special: false,
              }
            }
          })
        })
        return ret
      }
      
      const GetTurnAwayDir = (pos, workingFace) => {
        //var invf = GetInvolvedFaces(pos)
        switch(workingFace){
          case 'back':
            if(pos[2] == 1){
              if(pos[1] == 1){
                return pos[0] == 1 ? ['top', 1] : ['left', 1]
              }else{
                return pos[0] == 1 ? ['right', 1] : ['bottom', 1]
              }
            }
          break
          case 'top':
            if(pos[1] == 1){
              if(pos[2] == 1){
                return pos[0] == 1 ? ['back', -1] : ['left', -1]
              }else{
                return pos[0] == 1 ? ['right', -1] : ['front', -1]
              }
            }
          break
          case 'right':
            if(pos[0] == 1){
              if(pos[1] == 1){
                return pos[2] == 1 ? ['back', 1] : ['top', 1]
              }else{
                return pos[2] == 1 ? ['bottom', 1] : ['front', 1]
              }
            }
          break
          case 'front':
            if(pos[2] == -1){
              if(pos[1] == 1){
                return pos[0] == 1 ? ['top', -1] : ['left', -1]
              }else{
                return pos[0] == 1 ? ['right', -1] : ['bottom', -1]
              }
            }
          break
          case 'bottom':
            if(pos[1] == -1){
              if(pos[2] == 1){
                return pos[0] == 1 ? ['back', 1] : ['left', 1]
              }else{
                return pos[0] == 1 ? ['right', 1] : ['front', 1]
              }
            }
          break
          case 'left':
            if(pos[0] == -1){
              if(pos[1] == 1){
                return pos[2] == 1 ? ['back', -1] : ['top', -1]
              }else{
                return pos[2] == -1 ? ['front', -1] : ['bottom', -1]
              }
            }
          break
        }
      }
      
      const GetCurPos = (colors, ids = identities) => {
        var ret = [0, 0, 0]
        ids.forEach(face => {
          face.forEach(id => {
            var adj = Adjoining(id, ids)
            var clr = IdFaceLookup(id.id)
            var clrs = [clr]
            
            adj.forEach(ad => {
              var color = IdFaceLookup(ad.adjoining.id)
              if(clrs.indexOf(color) == -1) clrs.push(color)
            })
            
            var ct = 0
            clrs.forEach(clr => {
              colors.map(clr2 => {
                if(clr == clr2) ct++
              })
            })
            if(ct == colors.length){
              ret = [
                Math.round(id.x / sp / 1.2),
                Math.round(id.y / sp / 1.2),
                Math.round(id.z / sp / 1.2),
              ]
            }
          })
        })
        return ret
      }
      
      const GetInvolvedFaces = pos => {
        var ret = []
        if(pos[0] == -1) ret.push('left')
        if(pos[0] == 1) ret.push('right')
        if(pos[1] == -1) ret.push('bottom')
        if(pos[1] == 1) ret.push('top')
        if(pos[2] == -1) ret.push('front')
        if(pos[2] == 1) ret.push('back')
        return ret
      }
      
      const ShowOverlay = () => {
        var overlay = document.querySelectorAll('.overlay')[0]
        overlay.style.display = 'block'
      }
      
      window.HideOverlay = () => {
        var overlay = document.querySelectorAll('.overlay')[0]
        overlay.style.display = 'none'
      }
      
      const ShowGuide = () => {
        ShowOverlay()
        var el = document.querySelector('#guideFrame')
        el.src = 'https://srmcgann.github.io/objs/rubik/guide.pdf'
      }
      
      const AnalyzeFace = face => {
        return 
      }

      var showColorNames = false

      window.Draw = () => {

        var t = renderer.t
        renderer.Clear()

        renderer.z = 12
        
        // solving algorithm
        if(solving){
          var wf = solveSet.workingFace
          switch(solveSet.solvingStage){
            case 0:
              switch(solveSet.stageProgress){
                case 0:
                  solveSet.tgts = [1, 3, 5, 7]
                  // pick side with "most complete cross", go there
                  solveSet = GeneratesolveSet(identities)
                  var best = -1, tgtFace
                  solveSet.faces.map((face, fidx) => {
                    var ct = 0
                    var cc = face.set[4].colorName
                    solveSet.tgts.forEach(tgt => {
                      ct += face.set[tgt].colorName == cc ? 1 : 0
                    })
                    if(ct > best){
                      best = ct
                      tgtFace = fidx
                    }
                  })
                  var faceName = solveSet.faces[tgtFace].face
                  solveSet.workingFace = faceName
                  console.log(`chosen face: ${faceName}`)
                  
                  solveSet.faces.filter(v=>v.face==faceName)[0].set.map((id, idx) => {
                    if(
                      solveSet.tgts.filter(q=>q==idx).length &&
                      id.id != id.posId
                    ) id.special = true
                  })
                  
                  ViewSide(faceName)
                  solveSet.stageProgress++
                break
                case 1:
                  // complete the cross
                  
                  var newDataset = GeneratesolveSet(identities)
                  solveSet.faces = newDataset.faces
                  
                  solveSet.faces.filter(v=>v.face==wf)[0].set.map((id, idx) => {
                    if(
                      solveSet.tgts.filter(q=>q==idx).length &&
                      id.id != id.posId
                    ) id.special = true
                  })
                  

                  var selMoves = []
                  solveSet.faces.filter(v=>{
                    return v.face==wf
                  })[0].set.map((id, idx) => {
                    if(id.special){
                      if(id.fx){
                        var testFace = id.fx < 0 ? 'left' : 'right'
                      }else{
                        var testFace = id.fy < 0 ? 'top' : 'bottom'
                      }
                      var relFace = RelativeFace(wf, testFace)
                      //console.log(`suggeted: rotate ${relFace}`)
                      selMoves.push(relFace)
                    }
                  })
                  if(selMoves.length){
                    if(phase == 1){

                      var ids = structuredClone(identities)
                      var turns = j + 1
                      var data = solveSet
                      var sidx = tgtOris.filter(v=>v.name==wf)[0].oid
                      var set = data.faces[sidx].set
                      var cc = set[4].colorName
                      var ct = 0
                      solveSet.tgts.map(idx => {
                        ct += set[idx].colorName == cc ? 1 : 0
                      })
                    
                      var path = [], mind = ct, sugg = ''
                      selMoves.forEach(mv => {
                        var ids = structuredClone(identities)
                        for(var j = 0; j < 3; j++){
                          var dir = -1
                          var turns = j + 1
                          var data = TryRotateFace(mv, dir, ids, turns)
                          var sidx = tgtOris.filter(v=>v.name==wf)[0].oid
                          var set = data.faces[sidx].set
                          var cc = set[4].colorName
                          var ct = 0
                          solveSet.tgts.map(idx => {
                            ct += set[idx].colorName == cc ? 1 : 0
                          })
                          if(ct > mind){
                            mind = ct
                            sugg = {mv, ct, dir, turns}
                            //path.push({sugg, ct})
                          }
                        }
                      })
                      if(sugg){
                        curCursorView = sugg.mv
                        RotateFace(sugg.dir)
                      }else{
                        if(mind<4 && phase == 1){
                          curCursorView = Rn() < .65 ? 
                            selMoves[selMoves.length * Rn() | 0] : wf
                          RotateFace(-1)
                        }
                      }
                    }
                  }else{
                    if(phase == 1) solveSet.stageProgress++
                  }
                break
                case 2:
                  //console.log('ready for next step')
                  if(phase == 1){

                    var sidx = tgtOris.filter(v=>v.name==wf)[0].oid
                    //var newData = GeneratesolveSet(identities)
                    //solveSet.faces = newData.faces
                    var set = solveSet.faces[sidx].set
                    solveSet.matching = []
                    solveSet.tgts.forEach(tgt => {
                      var el = set[tgt]
                      
                      el = {
                        x: el.rx,
                        y: el.ry,
                        z: el.rz,
                        id: el.id,
                        posId: el.posId,
                      }
                      
                      var adj = Adjoining(el, identities)
                      adj.forEach(ad => {
                        if(ad.adjoining.id == ad.adjoining.posId) {
                          solveSet.matching.push(tgt)
                        }
                      })
                    })
                    if(solveSet.matching.length < 2){
                      if(phase == 1){
                        curCursorView = wf
                        RotateFace(1)
                      }
                    }else{
                      solveSet.stageProgress++
                    }
                  }
                break
                case 3:
                  if(phase == 1){
                    if(solveSet.matching.length < 4 &&
                      !solveSet.queue.length &&
                      !solveSet.memo.length){
                      solveSet.queue = []
                      solveSet.memo = []
                      var diff = Math.abs(solveSet.matching[1]-solveSet.matching[0])
                      console.log('diff', diff)
                      console.log('matching', solveSet.matching)
                      if((diff == 2 && solveSet.matching[0]==3) || diff == 6){
                        if(solveSet.matching[0] == 1){
                          var tgtFace = RelativeFace( wf, 'left')
                            for(var m=2; m--;)
                              solveSet.queue.push({ tgtFace, dir: -1 })
                          tgtFace = RelativeFace( wf, 'right')
                            for(var m=2; m--;)
                              solveSet.queue.push({ tgtFace, dir: 1 })
                        }else{
                          var tgtFace = RelativeFace( wf, 'top')
                            for(var m=2; m--;)
                              solveSet.queue.push({ tgtFace, dir: -1 })
                          tgtFace = RelativeFace( wf, 'bottom')
                            for(var m=2; m--;)
                              solveSet.queue.push({ tgtFace, dir: 1 })
                        }
                        solveSet.memo = [1]
                      }else{
                        solveSet.memo = [2]
                        console.log('2 match, but are not opposite')
                      }
                    }else{
                      if(solveSet.queue.length){
                        var mv = solveSet.queue.shift()
                        curCursorView = mv.tgtFace
                        RotateFace(mv.dir)
                      }else{
                        if(solveSet.matching.length == 4) {
                          console.log('4 match!')
                          solveSet.memo = [-1]
                          solveSet.stageProgress++
                        }else{
                          switch(solveSet.memo[0]){
                            case -1:
                              console.log('4 match!')
                              solveSet.stageProgress++
                              solveSet.matching = solveSet.tgts
                            break
                            // rotate backface, return
                            case 1: // rotate backface, return
                              var tgtFace = RelativeFace( wf, 'back')
                                for(var m=2; m--;)
                                  solveSet.queue.push({ tgtFace, dir: -1 })
                                if(solveSet.matching.indexOf(1) != -1){
                                  var tgtFace = RelativeFace( wf, 'left')
                                    for(var m=2; m--;)
                                      solveSet.queue.push({ tgtFace, dir: -1 })
                                  tgtFace = RelativeFace( wf, 'right')
                                    for(var m=2; m--;)
                                      solveSet.queue.push({ tgtFace, dir: 1 })
                                }else{
                                  var tgtFace = RelativeFace( wf, 'top')
                                    for(var m=2; m--;)
                                      solveSet.queue.push({ tgtFace, dir: -1 })
                                  tgtFace = RelativeFace( wf, 'bottom')
                                    for(var m=2; m--;)
                                      solveSet.queue.push({ tgtFace, dir: 1 })
                                }
                                solveSet.memo = [-1]
                            break
                            case 2: // non-opposites
                              var mode
                              if(solveSet.matching[0] == 1 && solveSet.matching[1] == 5) mode = 2
                              if(solveSet.matching[0] == 5 && solveSet.matching[1] == 7) mode = 3
                              if(solveSet.matching[0] == 3 && solveSet.matching[1] == 7) mode = 0
                              if(solveSet.matching[0] == 1 && solveSet.matching[1] == 3) mode = 1
                              var fc = []
                              switch(mode){
                                case 0:
                                  fc = [
                                    'right',
                                    'right',
                                    'top',
                                    'top',
                                    'back',
                                    'top',
                                    'top',
                                    'back',
                                    'back',
                                    'right',
                                    'right',
                                  ]
                                break
                                case 1:
                                  fc = [
                                    'bottom',
                                    'bottom',
                                    'right',
                                    'right',
                                    'back',
                                    'right',
                                    'right',
                                    'back',
                                    'back',
                                    'bottom',
                                    'bottom',
                                  ]
                                break
                                case 2:
                                  fc = [
                                    'left',
                                    'left',
                                    'bottom',
                                    'bottom',
                                    'back',
                                    'bottom',
                                    'bottom',
                                    'back',
                                    'back',
                                    'left',
                                    'left',
                                  ]
                                break
                                case 3:
                                  fc = [
                                    'top',
                                    'top',
                                    'left',
                                    'left',
                                    'back',
                                    'left',
                                    'left',
                                    'back',
                                    'back',
                                    'top',
                                    'top',
                                  ]
                                break
                              }
                              fc.map(f => {
                                tgtFace = RelativeFace( wf, f)
                                  solveSet.queue.push({tgtFace, dir: 1})
                              })
                              solveSet.memo = [-1]
                            break
                          }
                        }
                      }
                    }
                  }
                break
                case 4:
                  if(phase == 1){
                    if(solveSet.memo.length && solveSet.memo[0] == -1){
                      solveSet.memo = []
                      solveSet.queue = []
                      solveSet.matching = []
                      solveSet.tgts = [0, 2, 6, 8]
                    }
                    if(solveSet.matching.length < 4 &&
                      solveSet.queue.length == 0){
                      
                      var sidx = tgtOris.filter(v=>v.name==wf)[0].oid
                      var newData = GeneratesolveSet(identities)
                      solveSet.faces = newData.faces
                      var set = solveSet.faces[sidx].set
                      solveSet.matching = []
                      solveSet.tgtColors = newData.tgtColors
                      var colors
                      
                      if(solveSet.tgtColors.length == 0){
                        solveSet.tgtColors = [
                          {
                            complete: false,
                            status: '',
                            colors: colors = [
                              set[4].colorName,
                              FaceColorLookup(RelativeFace(wf, 'left')),
                              FaceColorLookup(RelativeFace(wf, 'top')),
                            ],
                            curPos: GetCurPos(colors)
                          },
                          {
                            complete: false,
                            status: '',
                            colors: colors = [
                              set[4].colorName,
                              FaceColorLookup(RelativeFace(wf, 'top')),
                              FaceColorLookup(RelativeFace(wf, 'right')),
                            ],
                            curPos: GetCurPos(colors)
                          },
                          {
                            complete: false,
                            status: '',
                            colors: colors = [
                              set[4].colorName,
                              FaceColorLookup(RelativeFace(wf, 'bottom')),
                              FaceColorLookup(RelativeFace(wf, 'left')),
                            ],
                            curPos: GetCurPos(colors)
                          },
                          {
                            complete: false,
                            status: '',
                            colors: colors = [
                              set[4].colorName,
                              FaceColorLookup(RelativeFace(wf, 'right')),
                              FaceColorLookup(RelativeFace(wf, 'bottom')),
                            ],
                            curPos: GetCurPos(colors)
                          },
                        ]
                      }
                      
                      solveSet.tgts.forEach((tgt, tidx) => {
                        var el = set[tgt]
                        
                        el = {
                          x: el.rx,
                          y: el.ry,
                          z: el.rz,
                          id: el.id,
                          posId: el.posId,
                        }
                        
                        var adj = Adjoining(el, identities)
                        var clrs = []
                        clrs.push(IdFaceLookup(el.id))
                        
                        adj.forEach(ad => {
                          var clr = IdFaceLookup(ad.adjoining.id)
                          if(clrs.indexOf(clr) == -1){
                            clrs.push(clr)
                          }
                        })
                        
                        var ct = 0
                        for(var i = 0; i < 3; i++){
                          var clr = clrs[i]
                          solveSet.tgtColors[tidx].colors.map(clr2 => {
                            if(clr == clr2) ct++
                          })
                        }
                        switch(ct){
                          case 0: case 1: case 2:
                            solveSet.tgtColors[tidx].status = 'wrong piece'
                          break
                          case 3:
                            if(el.id == el.posId){
                              solveSet.tgtColors[tidx].complete = true
                              solveSet.tgtColors[tidx].status = 'correct'
                            }else{
                              solveSet.tgtColors[tidx].status = 'right piece, wrong ori'
                            }
                          break
                        }
                      })
                      console.log('tgtColors', solveSet.tgtColors)
                      //console.log(set)
                      const DoMove = (tgt, onFace, tidx) => {
                        var coords = onFace ? tgt.curPos : [
                            set[solveSet.tgts[tidx]].x,
                            set[solveSet.tgts[tidx]].y,
                            set[solveSet.tgts[tidx]].z,
                          ]
                        var d = GetTurnAwayDir( coords, wf)
                        if(d && d.length){
                          var tgtFace = RelativeFace(wf, 'back')
                          if(Rn() < .5) solveSet.queue.push([tgtFace, -1])
                          solveSet.queue.push([d[0], d[1]])
                          solveSet.queue.push([tgtFace, 1])
                          if(Rn() < .5) solveSet.queue.push([tgtFace, 1])
                          solveSet.queue.push([d[0], -d[1]])
                          //solveSet.queue.push([tgtFace, 1])
                          //solveSet.queue.push([tgtFace, 1])
                          //solveSet.queue.push([d[0], d[1]])
                          //solveSet.queue.push([tgtFace, 1])
                          //solveSet.queue.push([d[0], -d[1]])
                        }
                      }
                      
                      if(solveSet.tgtColors.filter(v=>!v.complete).length){
                        var cur = tgtOriFromFace(wf)
                        var curFID = cur.oid
                        //console.log(set)
                        solveSet.tgtColors.map((tgt, tidx) => {
                          //if(solveSet.queue.length) return
                          //console.log(tgt)
                          switch(tgt.status){
                            case 'wrong piece':
                              var tStage, ct = 0
                              ct += set[4].x && tgt.curPos[0] == set[4].x ? 1 : 0
                              ct += set[4].y && tgt.curPos[1] == set[4].y ? 1 : 0
                              ct += set[4].z && tgt.curPos[2] == set[4].z ? 1 : 0
                              switch(tidx){
                                case 0: 
                                  tStage='upper left corner'
                                  if(ct){
                                    console.log(tStage, ' -> needed piece is on working face, in wrong spot')
                                    DoMove(tgt, ct, tidx)
                                  }else{
                                    var rel = RelativeFace(wf, 'back')
                                    console.log(tStage, ` -> needed piece is on rel-back face (${rel})`)
                                    DoMove(tgt, ct, tidx)
                                  }
                                break
                                case 1:
                                  tStage='upper right corner'
                                  if(ct){
                                    console.log(tStage, ' -> needed piece is on working face, in wrong spot')
                                    DoMove(tgt, ct, tidx)
                                  }else{
                                    var rel = RelativeFace(wf, 'back')
                                    console.log(tStage, ` -> needed piece is on rel-back face (${rel})`)
                                    DoMove(tgt, ct, tidx)
                                  }
                                break
                                case 2:
                                  tStage='lower left corner'
                                  if(ct){
                                    console.log(tStage, ' -> needed piece is on working face, in wrong spot')
                                    DoMove(tgt, ct, tidx)
                                  }else{
                                    var rel = RelativeFace(wf, 'back')
                                    console.log(tStage, ` -> needed piece is on rel-back face (${rel})`)
                                    DoMove(tgt, ct, tidx)
                                  }
                                break
                                case 3:
                                  tStage='lower right corner'
                                  if(ct){
                                    console.log(tStage, ' -> needed piece is on working face, in wrong spot')
                                    DoMove(tgt, ct, tidx)
                                  }else{
                                    var rel = RelativeFace(wf, 'back')
                                    console.log(tStage, ` -> needed piece is on rel-back face (${rel})`)
                                    DoMove(tgt, ct, tidx)
                                  }
                                break
                              }
                            break
                            case 'right piece, wrong ori':
                              if(1||!solveSet.tgtColors.filter(v=>v.status == 'wrong piece').length){
                                console.log('wrong ori...')
                                switch(tidx){
                                  case 0:
                                    tStage='upper left corner'
                                    console.log('...', tStage)
                                    ;([
                                      {f: 'top', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'top', d: -1},
                                      {f: 'back', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'top', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'top', d: -1},
                                    ]).map(ts=>solveSet.queue.push([
                                      RelativeFace(wf, ts.f), ts.d
                                    ]))
                                  break
                                  case 1: 
                                    tStage='upper right corner'
                                    console.log('...', tStage)
                                    ;([
                                      {f: 'right', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'right', d: -1},
                                      {f: 'back', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'right', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'right', d: -1},
                                    ]).map(ts=>solveSet.queue.push([
                                      RelativeFace(wf, ts.f), ts.d
                                    ]))
                                  break
                                  case 2:
                                    tStage='lower left corner'
                                    console.log('...', tStage)
                                    ;([
                                      {f: 'left', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'left', d: -1},
                                      {f: 'back', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'left', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'left', d: -1},
                                    ]).map(ts=>solveSet.queue.push([
                                      RelativeFace(wf, ts.f), ts.d
                                    ]))
                                  break
                                  case 3:
                                    tStage='lower right corner'
                                    console.log('...', tStage)
                                    ;([
                                      {f: 'bottom', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'bottom', d: -1},
                                      {f: 'back', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'bottom', d: 1},
                                      {f: 'back', d: 1},
                                      {f: 'bottom', d: -1},
                                    ]).map(ts=>solveSet.queue.push([
                                      RelativeFace(wf, ts.f), ts.d
                                    ]))
                                  break
                                }
                              }
                              //console.log(tStage, ' -> needed piece is in the right spot, but wrong ori')
                            break
                            case 'correct':
                              switch(tidx){
                                case 0: 
                                  tStage='upper left corner'
                                break
                                case 1:
                                  tStage='upper right corner'
                                break
                                case 2:
                                  tStage='lower left corner'
                                break
                                case 3:
                                  tStage='lower right corner'
                                break
                              }
                              //console.log(tStage, ' -> is positiioned and oriented correctly')
                            break
                          }
                        })
                      }else{
                        console.log('4 match!')
                        solveSet.memo = [-1]
                        solveSet.stageProgress++
                      }
                      
                      //solveSet.queue.push({ tgtFace, dir: -1 })
                    }else{
                      console.log('reached queue processing')
                      if(solveSet.queue.length){
                        var mv = solveSet.queue.shift()
                        console.log(mv)
                        curCursorView = mv[0]
                        RotateFace(mv[1])
                      }else{
                        if(solveSet.matching.length == 4) {
                          console.log('4 match!')
                          solveSet.memo = [-1]
                          solveSet.stageProgress++
                        }else{
                          console.log('reached dead zone')
                          curMove = []
                        }
                      }
                    }
                  }
                break
                case 5:
                  if(phase == 1){
                    if(solveSet.memo.length && solveSet.memo[0] == -1){
                      solveSet.memo = []
                      solveSet.queue = []
                      solveSet.matching = []
                      var relFaces =  [
                        tgtOriFromFace(RelativeFace(wf, 'left')),
                        tgtOriFromFace(RelativeFace(wf, 'top')),
                        tgtOriFromFace(RelativeFace(wf, 'right')),
                        tgtOriFromFace(RelativeFace(wf, 'bottom')),
                      ]
                      
                      
                      
                      
          //case 'back':
          //case 'top':
          //case 'right':
          //case 'front':
          //case 'bottom':
          //case 'left':
                      
                      
                      
                      relFaces.forEach(fc => {
                        switch(fc){
                          case 0:
                            switch(wf){
                              case 'top': case 'bottom':
                                solveSet.tgts.push({[1,0,1], [-1,0,1]})
                              break
                              case 'left': case 'right':
                                solveSet.tgts.push({[0,1,1], [0,-1,1]})
                              break
                            }
                          break
                          case 1:
                            switch(wf){
                              case 'back': case 'front':
                                solveSet.tgts.push({[1,1,0], [-1,1,0]})
                              break
                              case 'right': case 'left':
                                solveSet.tgts.push({[0,1,-1], [0,1,1]})
                              break
                            }
                          break
                          case 2:
                            switch(wf){
                              case 'top':
                              case 'bottom':
                                solveSet.tgts.push({[1,0,-1], [1,0,1]})
                              break
                              case 'front':
                              case 'back':
                                solveSet.tgts.push({[1,1,0], [1,-1,0]})
                              break
                            }
                          break
                          case 3:
                            switch(wf){
                              case 'top':
                              case 'bottom':
                                solveSet.tgts.push({[-1,0,-1], [1,0,-1]})
                              break
                              case 'right':
                              case 'left':
                                solveSet.tgts.push({[0,1,-1], [0,-1,-1]})
                              break
                            }
                          break
                          case 4:
                            switch(wf){
                              case 'front':
                              case 'back':
                                solveSet.tgts.push({[-1,-1,0], [1,-1,0]})
                              break
                              case 'right':
                              case 'left':
                                solveSet.tgts.push({[0,-1,1], [0,-1,-1]})
                              break
                            }
                          break
                          case 5:
                            switch(wf){
                              case 'top':
                              case 'bottom':
                                solveSet.tgts.push({[-1,0,-1], [-1,0,1]})
                              break
                              case 'back':
                              case 'front':
                                solveSet.tgts.push({[-1,1,0], [-1,-1,0]})
                              break
                            }
                          break
                        }
                      })
                    }
                    if(solveSet.matching.length < 4 &&
                      solveSet.queue.length == 0){

                        var sidx = tgtOris.filter(v=>v.name==wf)[0].oid
                        var newData = GeneratesolveSet(identities)
                        solveSet.faces = newData.faces
                        var set = solveSet.faces[sidx].set
                        solveSet.matching = []
                        solveSet.tgtColors = newData.tgtColors

                        console.log('wf', wf)
                        console.log(solveSet)

                    }
                  }
                break
              }
            break
          }
          if(curMove.length) Shift(...curMove)
        }else{
          if(!curMove || !Shift(...curMove)) ChooseMove()
        }

        DoKeys()
        var cView = peekView ? peekView : curView

        //ctx.clearRect(0,0,c.width,c.height)
        ctx.drawImage(overlay,0,0,c.width,c.height)

        if(1 || keyHasBeenPressed){
          ctx.fillStyle = '#FF0'
          ctx.font = 'italic ' + (fs = 36) + 'px verdana'
          ctx.textAlign = 'right'

          ctx.fillText('   VIEW:', c.width/2-20, 150+fs)
          ctx.textAlign = 'left'
          ctx.fillStyle = '#0F8'
          ctx.font = 'bold ' + (fs = 36) + 'px verdana'
          ctx.fillText(oscx||oscy ? 'ORBIT' : cView.toUpperCase(), c.width/2-10, 150+fs)

          /*ctx.fillStyle = '#FF0'
                      ctx.font = 'italic ' + (fs = 36) + 'px verdana'
                      ctx.textAlign = 'right'
                      ctx.fillText('   MODE:', c.width/2-20, 200+fs)
                      ctx.textAlign = 'left'
                      ctx.fillStyle = '#0F8'
                      ctx.font = 'bold ' + (fs = 36) + 'px verdana'
                      ctx.fillText(numlock?'CUBE':'CURSOR', c.width/2-10, 200+fs)
                      */
        }

        ctx.textAlign = 'center'
        if(shuffleTTL > t){
          ctx.fillStyle = '#0f8'
          var fs
          ctx.font = (fs = 64) + 'px verdana'
          var str = '|' + ('-').repeat((t*20|0)%10) + 'shuffling' + ('-').repeat((t*20|0)%10) + '|'
          ctx.fillText(str, c.width/2, 50 + fs)
          var str = '|' + ('-').repeat((t*20|0)%10) + '---------' + ('-').repeat((t*20|0)%10) + '|'
          ctx.fillText(str, c.width/2, c.height - 250 + fs)
        }

        if(renderer.cameraMode != 'fps'){
          var tgtYaw = tgtOris.filter(v=>v.name==cView)[0].yaw
          var tgtPitch = -tgtOris.filter(v=>v.name==cView)[0].pitch

          var vx = tgtYaw - camYaw
          var vy = tgtPitch - camPitch
          offsetz = Math.hypot(vx, vy)
          vx = Math.min(tracking, Math.abs(vx)) * (vx<0?-1:1)
          vy = Math.min(tracking, Math.abs(vy)) * (vy<0?-1:1)
          camYaw += vx
          camPitch += vy
          //renderer.yaw = C(t) * .1 - .5 + camYaw
          //renderer.pitch = S(t) * .1 - .25 + camPitch
        }

        //doOscillate = false //!clickState
        if(peekView || !doOscillate){
          var showDefault = !peekView &&
              !(enterKeyHasBeenPressed || mouseButtonHasBeenClicked)
          oscx = showDefault ? defaultOscx : 0
          oscy = showDefault ? defaultOscy : 0
        }else if(!peekView){
          oscx = S(t/2) * .5
          oscy = C(t/2) * .5
        }

        if(!peekView){
          oscx += orbitYaw
          oscy += orbitPitch
        }

        shapes.forEach(shape => {
          switch(shape.name){
            case 'background':
              //shape.yaw += .005
              shape.yaw = oscx
              shape.pitch = oscy
              renderer.Draw(shape)
              break
            case 'cursor':
              if(!numlock || solving){

                var cCursorView
                if(phase < 1){
                  cCursorView = curMove[0]
                }else{
                  cCursorView = curCursorView
                }
                shape.x= rubikShape.x
                shape.y = rubikShape.y
                shape.z = rubikShape.z
                shape.yaw = rubikShape.yaw
                shape.pitch = rubikShape.pitch
                shape.color = Coordinates.HSVToHex(0,0,.5)

                tgtYaw = tgtOris.filter(v=>v.name==cCursorView)[0].yaw
                tgtPitch = -tgtOris.filter(v=>v.name==cCursorView)[0].pitch
                for(var i = 0; i < baseCursorShape.length; i+=3){
                  x = baseCursorShape[i+0]
                  y = baseCursorShape[i+1]
                  z = baseCursorShape[i+2]

                  var rl = rubikShape.roll + 
                      (curMove[0] == cCursorView ? Math.PI/2 * phase * curMove[1]:0)
                  * (cCursorView == 'top' ||
                     cCursorView == 'bottom' ? -1 : 1)

                  p = Math.atan2(x, y) + rl
                  d = Math.hypot(x, y)
                  x = S(p) * d
                  y = C(p) * d

                  p = Math.atan2(y, z) + tgtPitch
                  d = Math.hypot(y, z)
                  y = S(p) * d
                  z = C(p) * d

                  p = Math.atan2(x, z) + tgtYaw
                  d = Math.hypot(x, z)
                  x = S(p) * d
                  z = -C(p) * d

                  shape.vertices[i+0] = x
                  shape.vertices[i+1] = y
                  shape.vertices[i+2] = z
                }

                shape.z = -C(offsetz * Math.PI) * 2
                renderer.Draw(shape)
              }
              break
            case 'rubiks cube':
              if(rubikShape.pitch > Math.PI/2 || rubikShape.pitch < -Math.PI/2){
                shape.yaw = camYaw - oscx
              }else{
                shape.yaw = camYaw + oscx
              }
              shape.pitch = camPitch + oscy
              shape.z = -C(offsetz * Math.PI) * 2
              renderer.Draw(shape)
              break
            default:
              //renderer.Draw(shape)
              break
          }
        })

        ctx.fillStyle = '#4f88'
        var forSort = []
        clickTargets.map((v, i) => {
          var a = []
          v[0].map((q, j) => {
            x = q[0]
            y = q[1]
            z = q[2]
            var ar = Coordinates.GetShaderCoord(x, y, z, rubikShape, renderer)
            a.push(ar)
          })
          if(Coordinates.PointInPoly2D(mx, my, a)){
            forSort.push([a, v[1], v[0]])
          }
        })
        if(forSort.length){
          numlock = solving
          forSort.sort((a, b)=>{
            var ax = 0
            var ay = 0
            var az = 0
            var bx = 0
            var by = 0
            var bz = 0
            a[2].map(v => {
              ax += v[0]
              ay += v[1]
              az += v[2]
            })
            b[2].map(v => {
              bx += v[0]
              by += v[1]
              bz += v[2]
            })
            ax /= a[0].length
            ay /= a[0].length
            az /= a[0].length
            bx /= b[0].length
            by /= b[0].length
            bz /= b[0].length


            var ar1 = Coordinates.GetShaderCoord(ax, ay, az, rubikShape, renderer)
            var ar2 = Coordinates.GetShaderCoord(bx, by, bz, rubikShape, renderer)

            x = renderer.x
            y = renderer.y
            z = renderer.z
            p = Math.atan2(y, z) - rubikShape.pitch
            d = Math.hypot(y, z)
            y = S(p) * d
            z = C(p) * d
            p = Math.atan2(x, z) - rubikShape.yaw
            d = Math.hypot(x, z)
            x = S(p) * d
            z = C(p) * d

            var d1 = Math.hypot(ax-x, ay-y, az-z)
            var d2 = Math.hypot(bx-x, by-y, bz-z)

            var w1
            if(Math.abs(Math.hypot(bx-b[2][0][0], by-b[2][0][1], bz-b[2][0][2]) - 
                        Math.hypot(ax-a[2][0][0], ay-a[2][0][1], az-a[2][0][2]))<.1){
              w1 = 0
            }else if(Math.hypot(bx-b[2][0][0], by-b[2][0][1], bz-b[2][0][2]) >
                     Math.hypot(ax-a[2][0][0], ay-a[2][0][1], az-a[2][0][2])){
              w1 = 1.5
            }else{
              w1 = -1.5
            }
            return d2 + w1 - d1


          })
          curCursorView = tgtOris[forSort[0][1]].name

          //ctx.beginPath()
          //forSort[0][0].map(q=>{
          //  ctx.lineTo(...q)
          //})
          //ctx.fill()

        }else{
          numlock = true
        }


        var buttonWidth = 250
        var bwidth, bheight
        document.body.style.cursor = 'default '
        highlighted = false
        var fillColor, fontColor, highlight
        const SetColors = button => {
          highlight = mx > x && mx < x + bwidth &&
            my > y && my < y + bheight
          if(highlight) {
            highlighted = true
            document.body.style.cursor = highlighted && button.enabled ?
                                          'pointer' : 'default'
          }
          if(button.enabled){
            fillColor = highlight ?
              button.highlightColor : button.buttonColor
            fontColor = button.fontColor
          }else{
            fontColor = '#888'
            fillColor = '#333'
          }
        }
        buttons.map((button, bidx) => {
          ctx.font = 'italic ' + (fs = 24) + 'px verdana'
          x = c.width - 400
          y = 100 + bidx* fs * 2
          bwidth = buttonWidth + fs*2
          bheight = fs*1.5
          switch(button.name){
            case 'set mode':
              SetColors(button)
              ctx.textAlign = 'center'
              var text = `${button.text} : ${numlock ? 'CUBE' : 'CURSOR'}`
              ctx.fillStyle = fillColor
              ctx.fillRect(x, y, bwidth, bheight)
              ctx.fillStyle = fontColor
              ctx.fillText(text, x + bwidth/2, y + fs*1.1)
              break
            case 'oscillation':
              SetColors(button)
              ctx.textAlign = 'center'
              var text = `${button.text} : ${button.clickState ? 'on' : 'off'}`
              ctx.fillStyle = fillColor
              ctx.fillRect(x, y, bwidth, bheight)
              ctx.fillStyle = fontColor
              ctx.fillText(text, x + bwidth/2, y + fs*1.1)
              break
            case 'set cube bottom':
              //buttons[bidx].enabled = !numlock
              SetColors(button)
              ctx.textAlign = 'center'
              var text = button.text
              ctx.fillStyle = fillColor
              ctx.fillRect(x, y, bwidth, bheight)
              ctx.fillStyle = fontColor
              ctx.fillText(text, x + bwidth/2, y + fs*1.1)
              break
            default:
              SetColors(button)
              ctx.textAlign = 'center'
              var text = button.text
              ctx.fillStyle = fillColor
              ctx.fillRect(x, y, bwidth, bheight)
              ctx.fillStyle = fontColor
              ctx.fillText(text, x + bwidth/2, y + fs*1.1)
              break
          }
          if(highlight && !clicked && clickedWhileHighlighted &&
             renderer.mouseButton !== -1 &&
             typeof renderer.mouseButton != 'undefined') {
            clicked = true
            switch(button.style){
              case 'one click':
                break
              case 'toggle':
                button.clickState = !button.clickState
                break
            }
            eval(button.script)
          }
        })
        while(rubikShape.pitch > Math.PI) rubikShape.pitch -= Math.PI*2
        while(rubikShape.pitch < -Math.PI) rubikShape.pitch += Math.PI*2
        
        identities.forEach((face, fidx) => {
          face.forEach((id, idx) => {
            var ar = Coordinates.GetShaderCoord(id.x, id.y, id.z,
                                        rubikShape, renderer)

            if(showColorNames) {
              if(ar && FaceIsVisible(id.posId)){
                ctx.textAlign = 'center'
                ctx.fillStyle = '#fff'
                ctx.strokeStyle = '#000'
                ctx.lineWidth = 3
                ctx.font = (fs = 250/ar[2]) + 'px verdana'
                var colorName = IdFaceLookup(id.id)
                ctx.strokeText(colorName, ar[0], ar[1]+fs/3)
                ctx.fillText(colorName, ar[0], ar[1]+fs/3)
              }
            }
          })
        })
        
        if(solving) {
          var str = solveSet.faces.map((face, fidx) => {
            face.set.map((id, idx) => {
              var ar = Coordinates.GetShaderCoord(id.rx, id.ry, id.rz,
                                        rubikShape, renderer)
              if(ar && FaceIsVisible(id.posId)){
                if(id.special){
                  var s = 500/ar[2]
                  ctx.fillStyle = '#8f4'
                  ctx.fillRect(ar[0]-s/2,ar[1]-s/2,s,s)
                }
                
                ctx.textAlign = 'center'
                ctx.fillStyle = '#fff'
                ctx.strokeStyle = '#000'
                ctx.lineWidth = 4
                ctx.font = (fs = 250/ar[2]) + 'px verdana'
                str = `idx: ${idx}` //id.colorName
                ctx.strokeText(str, ar[0], ar[1]+fs/3 - fs)
                ctx.fillText(str, ar[0], ar[1]+fs/3 - fs)
                str = `id: ${id.id}`
                ctx.strokeText(str, ar[0], ar[1]+fs/3)
                ctx.fillText(str, ar[0], ar[1]+fs/3)
                str = `posId: ${id.posId}`
                ctx.strokeText(str, ar[0], ar[1]+fs/3+fs)
                ctx.fillText(str, ar[0], ar[1]+fs/3+fs)

              }
            })
          })
        }
            
        if(phase == 1) {
          if(phase != oph){
            for(var i = 0; i < identities.length; i++){
              for(var k = 0; k < identities[i].length; k++){
                var mind = 6e6, tidx1
                var tx = identities[i][k].x
                var ty = identities[i][k].y
                var tz = identities[i][k].z
                for(var j = 0; j < identities.length; j++){
                  x = identities[j][4].x
                  y = identities[j][4].y
                  z = identities[j][4].z
                  if((d = Math.hypot(x-tx, y-ty, z-tz)) < mind){
                    mind = d
                    tidx1 = j
                  }
                }
                identities[i][k].posId = tidx1
              }
            }
          }
          idc = structuredClone(identities)
        }
        oph = phase
        if(!numlock){
          document.body.style.cursor = 'pointer'
        }
        
        phase = Math.round(phase*1e4)/1e4
      }
      
      if(1) setTimeout(()=>{
        Shuffle(true)
        mouseButtonHasBeenClicked = true
        setTimeout(()=>{
          SolveCube(true)
        }, 3100)
      }, 0)
      
      window.onload = () => loaded = true

    </script>
  </body>
</html>
